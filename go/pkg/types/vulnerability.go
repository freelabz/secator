// go/pkg/types/vulnerability.go
package types

import (
	"fmt"
	"strings"

	"github.com/freelabz/secator/pkg/console"
)

// Vulnerability represents a security vulnerability finding
type Vulnerability struct {
	BaseType
	Name        string   `json:"name"`
	Severity    string   `json:"severity"` // critical, high, medium, low, info
	MatchedAt   string   `json:"matched_at"`
	Host        string   `json:"host"`
	IP          string   `json:"ip"`
	Provider    string   `json:"provider"` // nuclei, sqlmap, etc.
	TemplateID  string   `json:"template_id,omitempty"`
	Tags        []string `json:"tags,omitempty"`
	References  []string `json:"references,omitempty"`
	Description string   `json:"description,omitempty"`
	MatcherName string   `json:"matcher_name,omitempty"`
}

func (v *Vulnerability) Type() string {
	return "vulnerability"
}

func (v *Vulnerability) ToMap() map[string]any {
	m := v.BaseType.ToMap()
	m["_type"] = "vulnerability"
	m["name"] = v.Name
	m["severity"] = v.Severity
	m["matched_at"] = v.MatchedAt
	m["host"] = v.Host
	m["ip"] = v.IP
	m["provider"] = v.Provider
	m["template_id"] = v.TemplateID
	m["tags"] = v.Tags
	m["references"] = v.References
	m["description"] = v.Description
	m["matcher_name"] = v.MatcherName
	return m
}

// VulnerabilityFromMap creates a Vulnerability from nuclei JSON output
func VulnerabilityFromMap(raw map[string]any) (*Vulnerability, error) {
	v := &Vulnerability{
		Provider: "nuclei",
	}

	// Extract info block (nuclei nests these fields)
	info, ok := raw["info"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("missing info block")
	}

	if name, ok := info["name"].(string); ok {
		v.Name = name
	}
	if severity, ok := info["severity"].(string); ok {
		v.Severity = severity
	}
	if desc, ok := info["description"].(string); ok {
		v.Description = desc
	}
	if tags, ok := info["tags"].([]any); ok {
		for _, t := range tags {
			if s, ok := t.(string); ok {
				v.Tags = append(v.Tags, s)
			}
		}
	}
	if refs, ok := info["reference"].([]any); ok {
		for _, r := range refs {
			if s, ok := r.(string); ok {
				v.References = append(v.References, s)
			}
		}
	}

	// Top-level fields
	if matchedAt, ok := raw["matched-at"].(string); ok {
		v.MatchedAt = matchedAt
	}
	if host, ok := raw["host"].(string); ok {
		v.Host = host
	}
	if ip, ok := raw["ip"].(string); ok {
		v.IP = ip
	}
	if templateID, ok := raw["template-id"].(string); ok {
		v.TemplateID = templateID
	}
	if matcherName, ok := raw["matcher-name"].(string); ok {
		v.MatcherName = matcherName
	}

	if v.Name == "" {
		return nil, fmt.Errorf("name field is required")
	}

	return v, nil
}

// String returns a formatted console representation
// Format: ðŸš¨ [Name] [severity] matched_at [tags]
func (v *Vulnerability) String() string {
	var parts []string

	// Name with emoji
	name := console.Green(v.Name)
	if len(v.References) > 0 {
		name += " ðŸ¡•"
	}
	parts = append(parts, fmt.Sprintf("ðŸš¨ [%s]", name))

	// Severity with color
	colorFn := console.SeverityColor(v.Severity)
	parts = append(parts, fmt.Sprintf("[%s]", colorFn(v.Severity)))

	// Matched at
	if v.MatchedAt != "" {
		parts = append(parts, v.MatchedAt)
	}

	// Tags
	if len(v.Tags) > 0 {
		parts = append(parts, console.JoinTags(v.Tags))
	}

	s := strings.Join(parts, " ")

	// Dim if low confidence (we don't have confidence in Go yet, but structure is ready)
	return s
}
